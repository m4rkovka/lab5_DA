\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{ulem}
\usepackage[russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\thispagestyle{empty}
\begin{center}
    {\Large Московский авиационный институт\\ (национальный исследовательский университет)}

    \vspace{48pt}

    {\large Факультет информационных технологий и прикладной математики}

    \vspace{36pt}

    {\large Кафедра вычислительной математики и~программирования}

    \vspace{48pt}
    
    Лабораторная работа \textnumero 5 по курсу \enquote{Дискретный анализ}

\end{center}
    
    \vspace{72pt}
    
    \begin{flushright}
    \begin{tabular}{rl}
    Студент: & А.\,Н. Марков \\
    Преподаватель: & Н.\,А. Зацепин \\
    Группа: & М8О-308Б \\
    Дата: & \\
    Оценка: & \\
    Подпись: & \\
    \end{tabular}
    \end{flushright}
    
    \vfill
    
    \begin{center}
    \bfseries
    Москва, \the\year
\end{center}

\newpage

\subsection*{Условие}
\begin{enumerate}
\item Общая постановка задачи 

Необходимо реализовать алгоритм Укконена построения суффиксного дерева за линейное время. Построив такое дерево для некоторых из выходных строк, необходимо воспользоваться полученным суффиксным деревом для решения своего варианта задания.

Алфавит строк: строчные буквы латинского алфавита (т.е. от a до z).

\item Вариант задания 

Вариант 4. Вариант алгоритма: Линеаризовать циклическую строку, то есть найти минимальный в лексикографическом смысле разрез циклической строки. 

\end{enumerate}

\subsection*{Метод решения}

Алгоритм Укконена реализован следующим образом. Каждый узел суффиксного дерева содержит целочисленные переменные для левого и правого концов подстроки, указатель на int, необходимый для неявного изменения правого конца подстроки листа (для неявных добавлений первого типа), суффиксную ссылку, которая либо указывает на вершину с таким же суффиксом только без первого символа, либо при отсутствии вершины на nullptr, указатель на родителя, булевская переменная, помечающая является ли узел листом, целочисленная переменная, содержащая номер листа. Также есть словарь с дочерними узлами для данной вершины. В дереве хранится текст, в конец которого добавляется терминальный символ, указатель на корень, указатель на последний элемент, с которым выполнялось добавление. Этот указатель необходим для добавления суффиксных ссылок.

При создании дерева сначала добавляем первый суффикс. Начинаем с первой фазы. Сначала происходит поиск места, в котором должно происходить добавление. Поиск может привести к следующим результатам:

\begin{itemize}
    \item Завершение на ребре. Могут быть случаи добавления 2 и 3. Если случай 2, то создастся вершина на ребре и дочерний узел для этой вершины. Такой дочерний узел будет листом. Если случай 3, то фаза заканчивается.
    \item Завершение в вершине. В моей реализации случай 1 невозможен, т.к. сразу в начале фазы добавляется конец суффикса, соответствующего данной фазе. А значит если поиск закончится в листе, то это приведет только к случаю 3. Случай 3 заканчивает фазу. Если поиск закончился во внутренней вершине, то создается дочерний узел для этой вершины, который становится листом.
\end{itemize}

После случая 2, если длина подстроки вершины больше единицы или равна единице, но родителем этой вершины не является корень, то должна создаться суффиксная связь между этой вершиной и вершиной, которая либо создается в следующем продолжении, либо уже существует, поэтому переменная 
$do_link$ устанавливается в true. Иначе создается суффиксная связь с корнем.

Линеаризация циклической строки:
Подается строка S.
\begin{enumerate}
    \item Строю суффиксное дерево по удвоенной строке SS\$, где \$ - терминальный символ.
    \item Прохожу дерево таким образом, что в каждой вершине прохожу по дуге с символом наименьшем в лексикографическом порядке.
\end{enumerate}

\subsection*{Описание программы}

Проект состоит из 3 файлов:
\begin{itemize}
    \item main.cpp - главный файл, в котором реализована функция main
    \item suffix\_tree.hpp - заголовочный файл, в котором находятся объявления классов вершины дерева и суффиксного дерева.
    \item suffix\_tree.cpp - файл, в котором содержатся реализации методов классов вершины дерева и суффиксного дерева.
\end{itemize}
\newpage
\subsection*{Дневник отладки}

При создании этой таблицы была использована история посылок.
\begin{table}[!htb]
\begin{tabular}{|m{2cm}|m{2cm}|m{3cm}|m{9cm}|}
\hline
№ & Время & Проблема & Описание \\
\hline
1-8 & 2020/10/30 & RE & Если фаза заканчивалась добавлением case3, то вершина, в которой завершался поиск, присваивалась last\_node. Но в analysis\_links, не учитывалось, что фаза может завершаться раньше времени. Поэтому если в last\_node была суффиксная ссылка, то в следующей фазе при поиске происходил переход по этой суффиксной ссылке, хотя этого происходить не должно было. Поэтому дерево строилось неправильно и при некоторых тестовых данных программа падала с segmentation fault. \\
\hline
9 & 2020/10/31 & Ожидает подтверждения & Ошибка была исправлена, путем того, что в случае завершения предыдущей фазы case3, поиск начинался с корня. Хоть чекер принял такое решение, но оно не оптимально. \\
\hline
10-11 & 2020/10/31 & RE & При оптимазации возникали ошибки в реализации построения суффиксного дерева, из-за которых программа падала с segmentation fault. \\
\hline
12 & 2020/01/08 & Ожидает подтверждения & Все ошибки были исправлены. \\
\hline
\end{tabular}
\end{table}

\newpage

\subsection*{Тест производительности}

Тесты создавались с помощью небольших программы generator.py. Создавались строки с n-ым количеством символов.

\begin{tikzpicture}
	\begin{axis}[ylabel=Время в мс,xlabel=Количество символов в строке, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
	    ( 20000000, 32312 )
	    ( 15000000, 23425 )
	    ( 10000000, 14594 )
	    ( 9000000, 12824 )
	    ( 8000000, 11125)
	    ( 7000000, 9505 )
	    ( 6000000, 8046 )
	    ( 5000000, 6441 )
	    ( 4000000, 4989 )
	    ( 3000000, 3646 )
	    ( 2000000, 2371 )
		( 1000000, 1117 )};
	\end{axis}

\end{tikzpicture}

\subsection*{Выводы}

В данной лабораторной работе был реализован алгоритм построения суффиксного за линейное время, а также алгоритм линеаризации циклической строки.

Так как я использовал словарь в вершинах для хранения дочерних узлов, построение суффиксного дерева имеет следующую временную оценку $O(m * logk)$, где m - количество символов в тексте, k - размер алфавита.

Сложность по времени алгоритма линеаризации циклической строки равна $O(2n * logk + n * logk) = O(n * logk)$, где n - длина изначального среза, k - размер алфавита.

Суффиксное дерево показалось мне одной из самых сложных структур данных для понимания. Но его можно применять для множества задач таких, как линеаризацию циклической строки, количество подстроки в текст, общие подстроки. Все эти задачи решаются за линейное время.

\end{document}